
var url = require('url');
var querystring = require('querystring');
var nodeStatic = require('node-static');
var isError = require('util').isError;

/**
 * Занимаеться разведение входящих HTTP потоков
 * @requires Core.HBSTemplateClass
 * @class Core.Route
 */

/**
 * Создаем класс для управления запросами
 * @param {Core.HBSTemplateClass} tmpl Класс генератора шаблонов
 * @constructor
 */
function Route(tmpl){

	/**
	 * Время создания класса
	 * @private
	 * @property {Date} __classCreated
	 */
	this.__classCreated = new Date();

	/**
	 * Шаблонизатор
	 * @private
	 * @property {Core.HBSTemplateClass} tmpl
	 */
	this.tmpl = tmpl;

	/**
	 * Список сереверо статики
	 * @private
	 * @property {Object} staticServer
	 */
	this.staticServer = {};

	/**
	 * Список путей роутинга
	 * @private
	 * @property {Array} routeList
	 */
	this.routeList = [];

	return this;
}

/**
 * Создать путь к статичным файлам
 * @method createStatic
 * @param  {String} folder Полный путь к папке
 * @param  {Object} config Файл настройки сервера статики (node-static)
 */
Route.prototype.createStatic = function(folder, config){
	// Дополняем конфиг
	var cfg = extend({
		cache: 3600,
		serverInfo: "aquaris/static-server",
		headers: {},
		gzip: false
	}, config || {});
	// Замыкание
	var me = this;

	// Создаем сервер
	this.staticServer[folder] ? 0 : this.staticServer[folder] = new nodeStatic.Server(folder, cfg);
};

/**
 * подключить роутинг к статичным файлам
 * @method static
 * @param  {String} route  Регулярное выражение для поиска в URL запроса
 * @param  {String} folder Полный путь к папке
 */
Route.prototype.static = function(route, folder){
	// Создаем сервер
	if (this.staticServer[folder]) {
		var StaticServer = this.staticServer[folder];
		// завязываем на него роутинг
		this.get(route, function(req, res){
			// var benchStaticTime = new Date()
			req.addListener('end', function () {
				StaticServer.serve(req, res, function (e, result) {
					if (e && (e.status === 404)) {
						res.writeHead(404, 'Not found');
						res.end('404 No found');
					}
					// console.log('HTTP::UI::Static %sms', new Date() - benchStaticTime)
				});
			}).resume();
		});
	} else {
		console.error('Файл сервер для пути %s не найден', folder);
	}
};

/**
 * Устанвливаем обработку пути
 * @method get
 * @param  {String}   route    Регулярное выражение для поиска в URL запроса
 * @param  {Function} callback Вызов функции при нахождении
 */
Route.prototype.get = function(route, callback) {
	this.routeList.push({
		R: new RegExp('^'+route+'/?$'),
		C: callback
	});
};

/**
 * Возвращает функции для обработки запросов HTTP
 * @method getRouter
 * @return {Function} Функция обработчик
 */
Route.prototype.getRouter = function(){
	var me = this;
	var routeLen = me.routeList.length;
	return function(req, res) {
		var urlParse = url.parse(req.url);
		// if(urlParse.pathname === '/Z0G99VD7LNRPQ8YEYLF7C'){
		// 	return res.end(time_ago(me.__classCreated))
		// }
		req.pathname = urlParse.pathname;
		req.query = urlParse.query;
		req.params = querystring.parse(urlParse.query);
		for (var i=0; i<routeLen; i++) {
			if (me.routeList[i].R.test(req.pathname)) {
				me.routeList[i].C(req, res);
				return true;
			}
		}
		// Возвращаем 404
		res.writeHead(404, 'Not found');
		if (me.tmpl) {
			var HTML = me.tmpl.error(404, null, req);
			// если есть ошибки возвращаем ошибку
			isError(HTML) ? res.end('Template error') : res.end(HTML);
		} else {
			res.end('Not found');
		}
	};
};


module.exports = Route;

/**
 * Стандартная функция слияния объектов
 * @method extend
 * @private
 * @member Core.Route
 */
function extend(target) {
	var sources = [].slice.call(arguments, 1);
	sources.forEach(function (source) {
		for (var prop in source) {
			target[prop] = source[prop];
		}
	});
	return target;
}
